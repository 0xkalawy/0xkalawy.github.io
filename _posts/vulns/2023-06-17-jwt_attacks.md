---
title: "JWT Basic Attacks"
classes: wide
header:
  teaser: /assets/images/Covers/jwt.png
ribbon:   DodgerBlue
description: "JWT is a data structure usually used for authentication, so how to hack it?"
categories:
  - Vulnerabilities
toc: true
---

**J**SON **W**eb **T**okens is a data format used to send data between the client and the server for authentication or authorization. <br> it’s useful as all data is stored on the client side rather than the server side.

# JWT Format

A JWT consists of 3 parts: a header, a payload, and a signature. each separated by a dot.

```plaintext
eyJraWQiOiI5MTM2ZGRiMy1jYjBhLTRhMTktYTA3ZS1lYWRmNWE0NGM4YjUiLCJhbGciOiJSUzI1NiJ9
```

## The Header

is a Base64url-encoded JSON object that contains metadata about the token itself like an algorithm.

## The Payload

is a Base64url-encoded JSON object that contains the actual data.

## The Signature

the signature is generated by hashing the header and the payload and then encrypting it.

As the signature is directly derived from the header and the payload, changing a single byte of the header or payload results in a mismatched signature so it helps to maintain integrity.

> Integrity is keeping the data not modified by an unauthorized person while transferring it.

Without knowing the server’s secret key, it shouldn’t be possible to generate the correct signature for a given header and payload.

# Attacks

> it’s worthy to read [how to work with JWT in Burp](https://portswigger.net/burp/documentation/desktop/testing-workflow/session-management/jwts) before you read these notes.

## Unverified Signature

JWT libraries provide two functions to deal with JWT: `decode` and `verify`. some developers miss that and just pass the token to `decode` only and deal with that information without any verification.

1. Just change the actual data and send the request.

<iframe src="https://giphy.com/embed/MeJ4mT0bgWxSOqDP0h" width="480" height="480" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>

## Accepting Tokens With No Signatures

the JWT header contains an `alg` parameter. This tells the server which algorithm was used to sign the token and, therefore, which algorithm it needs to use when verifying the signature.

if this parameter is assigned, there will be no signature so this token is called “unsecured JWT”.

> note that with `alg` is "none" the signature will be deleted but don’t delete the dot after the body

most servers reject tokens with "none" value in `alg`, but you can use classic obfuscation techniques, such as mixed capitalization and unexpected encodings to bypass.

1. Change the algorithm to none
1. Change the data and send the request
1. if not work try to obfuscate none i.e None or NoNe

## Brute-Forcing secrets

1. get a JWT token from the request
1. `hashcat -a 0 -m 16500 <token> <list>`
1. with the cracked key sign your new token

there is a well know secret wordlist [here](https://github.com/wallarm/jwt-secrets/blob/master/jwt.secrets.list).

> only `alg` is mandatory in the header. there are another parameters: <br> &ensp `jwk` (JSON Web Key) - Provides an embedded JSON object representing the key. <br> &ensp `jku` (JSON Web Key Set URL) - Provides a URL from which servers can fetch a set of keys containing the correct key. <br> &ensp `kid` (Key ID) - Provides an ID that servers can use to identify the correct key in cases where there are multiple keys to choose from.

## Injecting self-signed JWTs via the JWK parameter

The server should specify a whitelist with the private keys which can be submitted. However, misconfigured servers sometimes use any key that’s embedded in the `jwk` parameter.

1. Generate a new RSA key.
1. Send a request containing a JWT to Burp Repeater.
1. in the message editor, switch to the JSON Web Token tab and modify the token’s payload however you like.
1. Click Attack, then select Embedded JWK. When prompted, select your newly generated RSA key and click attack.
1. Send the request to test how the server responds

## Injecting self-signed JWTs via the JKU parameter

some servers let you use the `jku` (JWK Set URL) header parameter to reference a JWK Set containing the key. When verifying the signature, the server fetches the relevant key from this URL.

JWK Sets like this are sometimes exposed publicly via a standard endpoint, such as `/.well-known/jwks.json`.

1. Generate a new RSA Key from JWT Editor Keys tab in Burp’s tab bar.
1. Copy the key as JWK
1. Upload the key to a server
2. Modify the header of the request with kidof your token.
1. add `JKU` parameter and set its value to the URL of your token
1. click sign and send the request.

>with the previous steps, the server will get the key from our URL. we previously signed our token with this key. so boooom.

## Injecting self-signed JWTs via the kid parameter

it’s worth knowing that the server may have different keys for different tokens not only JWT and these keys are stored in JWK and the server use `kid` to point to JWK as the secret key. so if this JWK is stored in Data Base or in a file, the JWT can be attacked using `kid` parameter with directory traversal or SQL injection.

1. Change kid to `/dev/null`
1. sign new symmetric key as `AA==` (null encoded as base64)
1. change the body and sign the signature
1. send the request

> with the previous steps, the server goes to `/dev/null` (an empty file in Linux) file and get the key (surely will be `null`) and our data is signed with `null` key so it will success.

<iframe src="https://giphy.com/embed/AdEKm7s6AFcKyHWkIq" width="480" height="270" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>

# Mindmap

as I’m a mindmap fanboy, I create this:

![mindmap](file://assets/images/_posts/vulns/jwt_basic_attacks/mindmap.png)

# Reports

1. [HackerOne Jira](https://hackerone.com/reports/1103582)

# Labs

1. [PicoCTF](https://play.picoctf.org/practice/challenge/355?category=1&originalEvent=72&page=1)
1. [Portswigger](https://portswigger.net/web-security/jwt)